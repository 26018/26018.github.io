---
layout: post
title: 链表
tags: C语言 课本代码 链表
author: 金辉
data: 2020-03-14
cover: https://cdn.jsdelivr.net/gh/26018/img/image/无标题.png
subtitle: 链表示范
---

``` c
#include <stdio.h>
#include <stdlib.h>
typedef int ElemType;
typedef struct LNode
{
	ElemType data;
	struct LNode *next;
}LinkNode;

void InitList(LinkNode *&L)   ///初始化   创建一个结点 
{
	L = (LinkNode *)malloc(sizeof(LinkNode));
	L->next = NULL;
}

void print(int a[],int n)    //打印 一个数组 
{
	printf("数组元素：\n"); 
	for(int i=0;i<n;i++)
		printf("%3d",a[i]);	
}

bool ListEmpty(LinkNode *&L)   //判断是否为空   判断第一个结点的 指针域 即可判断是否为空 
{
	return L->next == NULL;
}

void Disp(LinkNode *L)     // 打印一个链表 
{
	LinkNode *p = L->next;   // p指向头结点 
	while(p!=NULL)
	{
		printf("%3d",p->data);
		p=p->next;      // p指向下一个结点 
	}
	printf("\n");
}

void CreateListF(LinkNode *&L,ElemType a[],int n) // 头插法 
{
	LinkNode *s;
	for(int i=0;i<n;i++)
	{
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		s->next = L->next;
		L->next = s; 
	}	
}

void CreateListR(LinkNode *&L,ElemType a[],int n)  //尾插法 
{
	LinkNode *s,*r;
	r = L; 
	for(int i=0;i<n;i++)
	{
		s = (LinkNode *)malloc(sizeof(LinkNode));
		s->data = a[i];
		r->next = s;
		r = s;
	}
	r->next = NULL;
 } 

void DestroyList(LinkNode *&L)    //释放链表 
{
	LinkNode *pre = L,*p=L->next;  // p 指向L的头结点 			
	while(p!=NULL)      
	{
		free(pre);    //释放头指针 
		pre = p;      //头指针重新指向p，也就是结点 
		p = pre->next; // p指向下一个结点 
	 } 
	 free(pre);
}

int ListLength(LinkNode *L)   // 求链表的长度 
{
	int n = 0;
	LinkNode *p = L;
	while(p->next!=NULL)
	{
		n++;
		p=p->next;
	}
	return n;
}

bool GetElem(LinkNode *L,int i,ElemType &e)    //求线性表中的某个位置的元素值 
{
	int j=0;
	LinkNode *p=L;
	if(i<=0)
		return false;
	while(j<i&&p!=NULL)
	{
		i++;
		p=p->next;
	}
	if(p==NULL)
		return false;
	else
	{
		e=p->data;
		return true;
	}
 } 
 
int LocateElem(LinkNode *L,ElemType e)  // 查找元素值e在链表中的位置 
{
	int i=1;
	LinkNode *p = L->next;
	while(p!=NULL&&p->data!=e)
	{
		p=p->next;
		i++;
	}
	if(p==NULL)
		return (0);
	else 
		return (i);
 } 
 
bool ListInsert(LinkNode *&L,int i,ElemType e)   //指定位置插入数据e     ***** 
{
	int j=0;
	LinkNode *p=L,*s;
	if(i<=0)
		return false;
	while(j<i-1&&p!=NULL)
	{
		j++;
		p=p->next;
	 } 
	 if(p==NULL)
	 	return false;
	else
		{
			s=(LinkNode *)malloc(sizeof(LinkNode));
			s->data = e;
			s->next = p->next;
			p->next = s;
			return true;
		}
 } 

bool ListDelete(LinkNode *&L,int i,ElemType &e)  // 删除指定位置的元素    **** 
{
	int j=0;
	LinkNode *p = L,*q;
	if(i<=0)
		return false;
	while(j<i-1&&p!=NULL)
	{
		j++;
		p=p->next;
	}
	if(p==NULL)
		return false ;
	else 
	{
		q=p->next;
		if(q==NULL)
			return false;
		e=q->data;
		p->next = q->next;
		free(q);
		return true;
	}
 } 

int main()
{
	int a[10] = {1,2,4,7,8,9,9,6,5,2};
	ElemType e;
	print(a,10);
	LinkNode *L1;
	InitList(L1);
	printf("\nEmpty:%d",ListEmpty(L1));
	CreateListF(L1,a,10);
	printf("\nDisp:\n");
	Disp(L1);
	CreateListR(L1,a,10);
	printf("\nEmpty:%d\n",ListEmpty(L1));
	Disp(L1);
	printf("\n%d in %d\n\n",8,LocateElem(L1,8) );
	printf("Delete:%d\nLocation:%d\n",ListDelete(L1,6,e),6);
	printf("Eelem:%d\n",e);
	Disp(L1);
	printf("Insert:%d\nLocation:%d\nElem:%d\n",ListInsert(L1,2,e),2,e);
	Disp(L1);
	printf("Length:%d",ListLength(L1));
	DestroyList(L1);
	return 0;
}

```